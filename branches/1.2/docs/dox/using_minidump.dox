/*!

\page using_minidump Using Crash Minidump

You can open minidump files generated by CrashRpt in Visual Studio or in WinDbg. 

This page covers the following topics:
  - \ref about_minidump
  - \ref opening_minidump_in_vs 
  - \ref opening_minidump_in_windbg 
  
\section about_minidump About Crash Minidump

The minidump (DMP file) contains various information about the state of 
the application when the error occurred. 
The minidump is usually created with the help of the DbgHelp DLL's 
\b MiniDumpWriteDump() function. 


The crash minidump file may contain:
  - general system information
  - call stack and local variables for each execution thread
  - values of global variables
  - the list of loaded and unloaded modules

The actual content of the minidump depends on the minidump type you pass 
as \ref CR_INSTALL_INFO::uMiniDumpType member.

In order to recover the stack trace from the crash minidump, 
you need the debugging symbols (program database, PDB) generated by the linker for important
modules of your application.

\section opening_minidump_in_vs Opening Minidump in Visual Studio

In order to illustrate how to open a minidump file, I will use the minidump file created for 
\b CrashRptTest.exe demo application that is distributed with CrashRpt archive. I use 
the following steps to create such minidump:

  - I download CrashRpt archive to some directory. Then I unzip my archive
    to <i>D:\\Projects\\CrashRpt\\dmptest</i> folder.
  - In the top-level directory, I open <i>CrashRpt_vs2005.sln</i> file (because I have Visual Studio 2005 installed)
    and compile CrashRpt in Release configuration as described in \ref compiling_crashrpt. 
  - Then I go to the <i>bin</i> directory. I see that the Visual Studio created several
    EXE, DLL and PDB files for me. Then I close Visual Studio window.
  - Next I save the binary files, debugging information and source code to some directory as described in 
    \ref preparing_to_release. I just copy the <i>bin</i> directory <i>D:\\Projects\\CrashRptSaved\\bin</i> directory
    and (because I use SVN to store my code) make SVN checkout to <i>D:\\Projects\\CrashRptSaved\\src</i> directory.
  - Next I go to the <i>bin</i> directory again and run the \b CrashRptTest.exe. When dialog appears, I click the
    "Crash" button. When Error Report dialog appears, I click the "What does this error report contains?"
    link. Then in the Error Report Details dialog, I click the "Export..." button to export the error report
    files as a ZIP archive. I export my error report to <i>D:\\Projects\\ErrorReports</i> directory.
  - And then I unzip the error report archive, which contains crashdump.dmp file and several other files.
  
Finally, I have the following directry structure:
  - D:\
     - Projects
        - CrashRpt
          - dmptest 
        - CrashRptSaved
          - bin 
          - src
        - ErrorReports 

Now, when you have crashdump.dmp file, you can open it in Visual Studio. In order to open crash minidump file, 
double-click its file name. Alternatively, right-click its name if
you have several versions of Visual Studio installed (for example a commercial one and an Express edition) and 
in the context menu select <i>Open With</i> and choose what Visual Studio version to use. A new Visual Studio window
will appear. 

In the Visual Studio window, you should be able to see the solution called 
<i>crashdump</i> and having single project node called <b>crashdump.dmp</b>.

\image html crashdump_sln.png "Solution Explorer: crashdump"

In the Visual Studio window, open menu <i>Debug->Start debugging</i> (or press F5) to load the minidump data. 
In the Output window, you should be able to see symbol file loading progress. If you do not see the Output window,
open menu <i>View</i> and click the <i>Output</i> menu item.

image

Now look at the Modules window. If you do not see such window, open menu Debug->Windows and select the "Modules"
menu item. 

Click the Symbol Status column header to order modules by symbol load status. Now should be you able to see that 
symbols are loaded for CrashRptTest.exe, CrashRpt.dll. 

image

How does Visual Studio locates 
   
As the debug symbols seem to be loaded successfully for main modules of your application, you should be able to see
the place in your source code where the exception occurred. I see that the crash occurred in file CrashRpt.cpp at
line 1240 inside of crEmulateCrash() function because of assigning a null pointer variable with a value.

My programming experience tells me that one of the most probable reasons of program crash is using a pointer to a 
variable without checking if it is not equal to NULL. So, in most cases such check would make the code more robust.

You can even edit the source code in the source code window to fix the problem. But I wouldn't recommend to do this.
Visual studio makes all names lowercase. And your code is stored in another place.

image

But it is more interesting for me to see what class or function called the crEmulateCrash() function and for what purpose.
I can do this with the help of the call stack (see the figure below). Open the <i>Call Stack</i> window to see 
the stack. If the Stack trace window is hidden, open menu Debug->Windows and select the 'Stack trace' item.

\image html call_stack.png "Fragment of code where exception occurred and the call stack"

Each line of the stack trace contains the name of module where crash occurred, the name of symbol 
(function or class), offset from beginning of symbol code, source file and line number. Moving down the stack,
I see that crEmulateCrash() was called by the CMainDlg::DoCrash() class method, which, in turn was called by 
the CMainDlg::OnOK method as the result of button click. No I understand what happened before the crash. 

Typically, the program has several execution threads. You can switch between threads using the 
<i>Threads</i> tab and browse the stack for each thread. I see that there are two threads: __tMainCRTStartup and
CrashThread. The exception occured in the main thread, the second thread didn't crash.

Finally, when you have finished with analyzing minidump data, close the Visual Studio window. If Visual Studio offers
you to save the solution, click the 'No' button.

\section troubleshooting_pdb Troubleshooting

Sometimes you can't determine the location of the crash and the error message is displayed
'No symbols loaded for any stack frame'. This may be because of the following reasons.

- Debugger may not locate the correct PDB and binary files. Try to open Tools->Options->Debugging->Symbols
  and enter the path to the directory where your PDB files are located (see the figure below for example). Then reopen the minidump.

\image html symbols_load_paths.png "Where to load symbols from"

- You may have wrong or missing PDB files. Open the Modules window (presented below) and check the symbol status
  for modules of your program. If the status is 'No symbols loaded.' than you have missing PDB. 
  Or maybe correct PDB files weren't saved locally before software release.
  In such case you won't be able to properly read any of received crash reports.

\image html modules.png "Symbols Loaded status for each module"

- If symbols for some modules of your program are loaded, and you have the error, than
  there were no debugging symbols generated for the module where crash had occurred. Check that
  you set Program Database (/Zi) compiler flag and Generate Debug Info (/DEBUG) linker flag 
  for all modules of your application. For additional info, see \ref prgdb                   

\section opening_minidump_in_windbg Opening Minidump in WinDbg

You can use \b WinDbg program from <b>Microsoft Debugging Tools for Windows</b> framework for opening 
crash minidumps. It is freely distributed. However, if you have Visual Studio installed,
it may be more convenient for you to use Visual Studio.

Let's show how to use WinDbg using an example. Run the sample CrashRptTest application that presents in
CrashRpt package, and then click on any button to generate an exception. Then extract the crashdump.dmp file 
from the crash report, launch WinDbg, and open the crash dump by pressing CTRL+D.

Next, you need to set the symbol path for WinDbg with the .sympath command. Switch 
to the command window (ALT+1) and enter \c .sympath followed by a space followed by the 
semi-colon delimited list of directories to search.

\code
.sympath D:\CrashRptSaved\CrashRptTest_v1.1.0
\endcode

Similarly you need to set the executable and source search paths with the .exepath 
and \c .srcpath commands.

\code
.exepath D:\CrashRptSaved\CrashRptTest_v1.1.0
.srcpath D:\Projects\CrashRpt\CrashRptTest\src
\endcode

The final step is to change the debugger context to the context record associated 
with the exception by entering the \c .ecxr command.

\code
.ecxr
\endcode

If everything is configured correctly, you should now be able to walk the call stack, 
see local variables, and loaded modules. You can even have WinDbg highlight the offending 
line of code by double clicking the CrashRptTest frame in the Call Stack window (ALT+6). 
Note: The exact line number may be a little off due to linker optimizations.

<b>Do program optimizations (/O compiler switch) affect the minidump generation?</b>

Yes, if you enable optimizations, the stack trace recovered from minidump may be incomplete. 
However, this is not the reason to turn the optimizations off. Instead, you can manage some 
error log file which is not affected by optimizations. 

<b>If I've saved all the source code, should building from the source recreate the correct 
PDBs to be able to use them for reading the minidump?</b>

No, the recreated PDB files will not be the same as the original ones. The recreated 
PDB files won't have matching time stamp (or GUID in a never versions of dbghelp). The 
building environment may also be different, so generated binaries may be different.

The recommended way is to save the original PDB files (that were produced when building 
the project), binary files (EXE and DLL) along with the source code. 

*/