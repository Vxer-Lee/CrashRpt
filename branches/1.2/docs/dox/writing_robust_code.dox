/*!

\page writing_robust_code Making Your Code Robust

Analyzing many crash reports and fixing many errors makes you to think about how to 
write code that would be more stable. This page describes some best practices of 
writing C++ code robust to errors. A program that conforms to these rules is less 
likely to crash.

This page contains the following coding rules:

- \ref init_vars
- \ref validate_input
- \ref init_func_output

\section init_vars Always Initialize Local Variables

Not ininitialized local variables are a common reason of program crashes. For example,
see the following code fragment:

\code    
  // Define local variables

  BOOL bExitResult; // This will be TRUE if the function exits successfully
  NOTIFYICONDATA nid; // This WinAPI structure is used to add a tray icon
  FILE* f; // Handle to file
  TCHAR szBuffer[_MAX_PATH];   // String buffer
  HDC hDC; // Handle to GDI display device context
  HBITMAP hBitmap; // Handle to GDI bitmap
  LPBYTE pData[512]; // Buffer  
    
  // Do something with variables above...
\endcode

The code fragment above can be a potential reason of a crash, because none
of local variables is initialized. The correct code would be the following:

\code
  // Define local variables
  
  // Initialize function exit code with FALSE to indicate failure assumption
  BOOL bExitResult = FALSE; // This will be TRUE if the function exits successfully

  // Use ZeroMemory() or memset() to initialize structure 
  // And do not forget to init cbSize member!
  NOTIFYICONDATA nid; // This WinAPI structure is used to add a tray icon
  memset(&nid, 0, sizeof(NOTIFYICONDATA));
  nid.cbSize = sizeof(NOTIFYICONDATA));

  // Initialize file handle with NULL
  FILE* f = NULL; // Handle to file

  // Initialize string buffer with empty string
  TCHAR szBuffer[_MAX_PATH] = _T("");   // String buffer

  // Initialize GDI handles with NULL
  HDC hDC = NULL; // Handle to GDI display device context
  HBITMAP hBitmap = NULL; // Handle to GDI bitmap
  
  // Use ZeroMemory() or memset() to initialize a buffer
  LPBYTE pData[512]; // Buffer
  memset(pData, 0, 512); // Init buffer with zeroes

  // Do something with variables above...
\endcode 
                   
\section Initialize class member variables

\code

class CVehicle
{
public:

   CVehicle();
   ~CVehicle();

private:
   
   int m_nWheelCount;
   UINT m_nValveCount;
   CSize m_Dimensions;
   TCHAR m_szModel[_MAX_MODEL_NAME];
   std::string m_sManufacturer;
   CString m_sDriverName;
};

\endcode

\section validate_input Validate Function Input 

Preconditions and postconditions
It is recommended to validate function input parameters.

\code

  BOOL DrawCircles(HWND hWnd, LPRECT prcDraw, int nCircleCount)
  {
    // Check that window is valid
    if(!IsWindow(hWnd))
      return FALSE;

    // Check that drawing rect is valid
    if(prcDraw==NULL)
      return FALSE;

    // Check count of circles to draw is valid
    if(nCircleCount<0 || nCircleCount>10)
      return FALSE;
   
    // Now it's safe to draw the circles

    return TRUE;
  }
  
\endcode

\section Check NULL pointers


\section init_func_output Always Initialize Function Output

\code

  int CreateObject(CObject** ppObject)
  {
    *ppObject = NULL;

    if(CanCreateObject())
    {
      *ppObject = new CObject();
      return 1;
    }    

    return 0;
  }

\endcode

\section Use Asserts Carefully

\section Check return code of a function

\section Use left-side == operator

\code
 
  int nItemCount = 10;
  if(0==nItemCount)
  {
  } 
 
\endcode

\section Use STL Containers 

\code

  // Initialize column widths
  int* pColumnWidths = new int[10];
  int i;
  for(i=0; i<10; i++)
  {
    pColumnWidths[i] = 50;
  }

\endcode

\section static_checks Using SAL macros 

\section automated_testing Using Automated Tests

\section Properly use line indenting

\section Use consistent programming style

Use Hungarian notation

\section Avoid complex conditional expressions

\section Compile your code at warning level 4

\section Keep your code clean of compiler warnings

\section Use smart pointers

\section Choose meaningful variable names

\section Comment your code 

\section Remove junk comment blocks

\section Using goto instruction

Some people say that goto statements violate the idea of structured code. 
Only in some very few cases (for instance breaking out of deeply nested 
structures) should goto be considered, and only if the alternative 
structured counterpart is proven to be less readable.

\section Switch statement 

\section Try-catch statement 

\section Clean up in class destructor

\section Check for division by zero

\section Use macros carefully

\section Use type conversion carefully

\section Initialize cbSize member of WinAPI structures

\section Use safe CRT functions

\section Explicitly define calling convention

\section Thread safety (critical sections)

Safe memory allocation new delete []

\section Use UINT type carefully

UINT overflow

\section Clean up pointers to deleted objects

Assign NULL to a pointer after freeing (or deleting) it.

\section Allocate memory carefully

Ensure that 0 (zero) bytes are not allocated using malloc. 

http://www.codeproject.com/KB/tips/CBP_for_memory_allocation.aspx

How to write robust code http://www.iovene.com/28/
http://geosoft.no/development/cppstyle.html
http://www.doc.ic.ac.uk/lab/cplus/c%2b%2b.rules/chap4.html#sect2
http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Header_Files

*/