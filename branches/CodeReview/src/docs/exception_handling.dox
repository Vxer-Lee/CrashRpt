/*!

\page exception_handling About Exceptions and Exception Handling

This page describes basic techniques of handling errors in a Windows application. CrashRpt
uses the techniques described below internally.

The page covers the following topics:

- \ref about_exceptions
- \ref structured_exc
- \ref crt_errors
- \ref cpp_signals
- \ref exception_handling_reference

\section about_exceptions About Exceptions

An exception or an error typically means that a program stops working normally and needs to close. 

For example, an exception may occur because of the following:

- program accesses an invalid memory address (such as NULL pointer)
- stack is overflown due to infinite recursion 
- large block of data is written to a small buffer
- a pure virtual method of a C++ class is called
- memory buffer can't be allocated (out of memory)
- invalid parameter is passed to a C++ system function
- C++ run time libraries detect an error and request program termination

An exception may be raised by CPU or by a software program. These two kinds of
exceptions are called hardware and software exceptions, respectively. From point of developer's
view there is no difference between software and hardware exceptions.

\section structured_exc Structured Exceptions

Exceptions generated by Windows are called structured exceptions. When such an exception occurs,
you typically see a popup window (DrWatson) that offers to send error report to Microsoft. 

You can generate a structured exception yourself using \b RaiseException() function.

You can catch a structured exception in your code using __try{}__except(Expression){} construction.
The \b main() function of your program is guarded with such construction, so by default all unhandled
structured exceptions are cougth and DrWatson is invoked.

Example:

\code
  int* p = NULL;   // pointer to NULL
  __try
  {
    // Guarded code

    *p = 13; // causes an access violation exception;
  }
  __except() // Here is exception filter
  {  
    // Here is exception handler
 
    // Terminate program
    ExitProcess(1);
  }
\endcode 

Each structured exception has an exception code. You can extract the exception code inside of __except statement 
using \b GetExceptionCode() intrinsic function. You can extract exception information inside of __except 
statement using \b GetExceptionInformation() intrinsic function. To use these intrinsic functions you usually
create your custom exception filter as shown in the example below.

The following example shows how to use a structured exception filter.

\code 

int seh_filter(unsigned int code, struct _EXCEPTION_POINTERS* ep)
{
  // Generate error report

  // Execute exception handler
  return EXCEPTION_EXECUTE_HANDLER;
}

void main()
{
  __try
  {
    // .. some unsafe code here
  }
  __except(seh_filter(GetExceptionCode(), GetExceptionInformation()))
  {    
    // Terminate program
    ExitProcess(1);
  }
}

\endcode

The __try{}__except(){} construction is mostly C oriented. However, you can redirect a structured exceptions to a C++
typed exception and handle it as you do with C++ typed exceptions. This can be done using the \b _set_se_translator() 
function provided by C++ runtime libraries (CRT).

Example taken from MSDN:

\code

// crt_settrans.cpp
// compile with: /EHa
#include <stdio.h>
#include <windows.h>
#include <eh.h>

void SEFunc();
void trans_func( unsigned int, EXCEPTION_POINTERS* );

class SE_Exception
{
private:
    unsigned int nSE;
public:
    SE_Exception() {}
    SE_Exception( unsigned int n ) : nSE( n ) {}
    ~SE_Exception() {}
    unsigned int getSeNumber() { return nSE; }
};
int main( void )
{
    try
    {
        _set_se_translator( trans_func );
        SEFunc();
    }
    catch( SE_Exception e )
    {
        printf( "Caught a __try exception with SE_Exception.\n" );
    }
}
void SEFunc()
{
    __try
    {
        int x, y=0;
        x = 5 / y;
    }
    __finally
    {
        printf( "In finally\n" );
    }
}
void trans_func( unsigned int u, EXCEPTION_POINTERS* pExp )
{
    printf( "In trans_func.\n" );
    throw SE_Exception();
}

\endcode


The disadvantage of the try-catch construction is that you may forget to guard a potentially buggy or unsafe 
code that may cause an exception that won't be handled by your program. However, such an unhandled exception
can be catched using the unhandled exception filter set with the \b SetUnhandledExceptionFilter() function.

The exception information (CPU state before the exception occured) is passed to the unhandled exception handler
through \b EXCEPTION_POINTERS structure.

Example:

\code

LONG WINAPI MyUnhandledExceptionFilter(PEXCEPTION_POINTERS pExceptionPtrs)
{
  // Do something, for example generate error report

  //..

  // Execute default exception handler next
  return EXCEPTION_EXECUTE_HANDLER; 
}

void main()
{ 
  SetUnhandledExceptionFilter(MyUnhandledExceptionFilter);

  // .. some unsafe code here 
}

\endcode

The unhandled exception handler works for all threads of the caller process, so its enough to call it once
in the beginning of your \b main() function.

\section crt_errors CRT Error Handling

In addition to WIN32 structured exceptions, C++ runtime libraries (CRT) provide their own
error handling mechanism that should be taken into account in your program.

When CRT encounters an error, it may call \b unexpected() or \b terminate() functions. To intercept 
such calls and take an appropriate action you should set error handlers using \b set_unexpected()
and \b set_terminate() functions.

Example:

\code
void my_terminate_handler()
{
  // Abnormal program termination (terminate() function was called)

  // Do something here

  // Finally, terminate program
  exit(1); 
}

void main()
{
  set_terminate(my_terminate_handler);

  terminate();
}

\endcode

\note
In a multithreaded environment, unexpected and terminate functions are maintained 
separately for each thread. Each new thread needs to install its own 
unexpected and terminate function. Thus, each thread is in charge of its own unexpected and
terminate handling.

Use the \b _set_purecall_handler() function to handle pure virtual function calls. This function can be used
in VC++ .NET 2003 and later. This function works for all threads of the caller process.

Example (taken from MSDN):

\code
// _set_purecall_handler.cpp
// compile with: /W1
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>

class CDerived;
class CBase
{
public:
   CBase(CDerived *derived): m_pDerived(derived) {};
   ~CBase();
   virtual void function(void) = 0;

   CDerived * m_pDerived;
};

class CDerived : public CBase
{
public:
   CDerived() : CBase(this) {};   // C4355
   virtual void function(void) {};
};

CBase::~CBase()
{
   m_pDerived -> function();
}

void myPurecallHandler(void)
{
   printf("In _purecall_handler.");
   exit(0);
}

int _tmain(int argc, _TCHAR* argv[])
{
   _set_purecall_handler(myPurecallHandler);
   CDerived myDerived;
}
\endcode

Use the \b _set_new_handler() function to handle memory allocation faults. This function can be used
in VC++ .NET 2003 and later. This function works for all threads of the caller process. 

Example (taken from MSDN):

\code
#include <new.h>
int handle_program_memory_depletion( size_t )
{
   // Your code
}
int main( void )
{
   _set_new_handler( handle_program_memory_depletion );
   int *pi = new int[BIG_NUMBER];
}
\endcode

In Visual C++ .NET 2003, you can use \b _set_security_error_handler() function to handle buffer overrun errors. This
function is declared deprecated and is removed from CRT in later versions of VC++. 

Use the \b _set_invalid_parameter_handler() function to handle situations when CRT detects an invalid argument in
a system function call. This function can be used
in VC++ 2005 and later. This function works for all threads of the caller process.

Example (taken from MSDN):

\code
// crt_set_invalid_parameter_handler.c
// compile with: /Zi /MTd
#include <stdio.h>
#include <stdlib.h>
#include <crtdbg.h>  // For _CrtSetReportMode

void myInvalidParameterHandler(const wchar_t* expression,
   const wchar_t* function, 
   const wchar_t* file, 
   unsigned int line, 
   uintptr_t pReserved)
{
   wprintf(L"Invalid parameter detected in function %s."
            L" File: %s Line: %d\n", function, file, line);
   wprintf(L"Expression: %s\n", expression);
}


int main( )
{
   char* formatString;

   _invalid_parameter_handler oldHandler, newHandler;
   newHandler = myInvalidParameterHandler;
   oldHandler = _set_invalid_parameter_handler(newHandler);

   // Disable the message box for assertions.
   _CrtSetReportMode(_CRT_ASSERT, 0);

   // Call printf_s with invalid parameters.

   formatString = NULL;
   printf(formatString);
}
\endcode

\section cpp_signals C++ Signal Handling

C++ provides program interruption mechanism called signals. You can handle signals with the \b signal()
function. 

In Visual C++, there are 6 types of signals: 

 - \c SIGABRT Abnormal termination
 - \c SIGFPE  Floating-point error
 - \c SIGILL  Illegal instruction
 - \c SIGINT  CTRL+C signal
 - \c SIGSEGV Illegal storage access
 - \c SIGTERM Termination request

MSDN say that the \c SIGILL, \c SIGSEGV, and \c SIGTERM signals are not generated unded Windows NT and 
included for ANSI compatiblity. 

You can generate all 6 signals manually using \b raise() function. 

Example:

\code

void sigabrt_handler(int)
{
  // Caught SIGABRT C++ signal

  // Terminate program
  exit(1);
}

void main()
{
  signal(SIGABRT, sigabrt_handler);
     
  // Cause abourt
  abort();       
}                

\endcode

\note
Although it is not well documented in MSDN, it seems that you should install SIGFPE, SIGILL and SIGSEGV 
signal handlers for each new thread in your program. The SIGABRT, SIGINT and SIGTERM signal handlers
seems to work for all threads of the caller process, so you should install them once in your \b main()
program.

\section exception_handling_reference Reference

- <a href="http://msdn.microsoft.com/en-us/library/ms680657%28VS.85%29.aspx">Structured Exception Handling</a>                     
- <a href="http://msdn.microsoft.com/en-us/library/ms680634%28VS.85%29.aspx">SetUnhandledExceptionFilter()</a>
- <a href="http://msdn.microsoft.com/en-us/library/ms680552%28VS.85%29.aspx">RaiseException()</a>
- <a href="http://msdn.microsoft.com/en-us/library/ms679357%28VS.85%29.aspx">GetExceptionInformation()</a>
- <a href="http://msdn.microsoft.com/en-us/library/ms679356%28VS.85%29.aspx">GetExceptionCode()</a>
- <a href="http://msdn.microsoft.com/en-us/library/t6fk7h29%28VS.71%29.aspx">set_terminate()</a>
- <a href="http://msdn.microsoft.com/en-us/library/h46t5b69%28VS.71%29.aspx">set_unexpected()</a>
- <a href="http://msdn.microsoft.com/en-us/library/5z4bw5h5%28VS.71%29.aspx">_set_se_translator()</a>
- <a href="http://msdn.microsoft.com/en-us/library/ms395801%28VS.71%29.aspx">_set_security_error_handler()</a>
- <a href="http://msdn.microsoft.com/en-us/library/t296ys27%28VS.71%29.aspx">_set_purecall_handler()</a>
- <a href="http://msdn.microsoft.com/en-us/library/a45x8asx%28VS.71%29.aspx">_set_new_handler()</a>
- <a href="http://msdn.microsoft.com/en-us/library/a9yf33zb%28VS.80%29.aspx">_set_invalid_parameter_handler()</a>
- <a href="http://msdn.microsoft.com/en-us/library/xdkz3x12%28VS.71%29.aspx">signal()</a>
- <a href="http://msdn.microsoft.com/en-us/library/dwwzkt4c%28VS.71%29.aspx">raise()</a>

*/
