#summary Frequently Asked Questions
#labels Featured,Phase-Deploy

= General Questions =

== What is crashrpt? ==

CrashRpt library is an open source error handling, reporting and processing tool for applications created in Microsoft Visual C++ and running under Windows. 

== What license does crashrpt use? ==

CrashRpt is distributed under the New BSD License. For the license text, please see [http://crashrpt.sourceforge.net/License.txt here].

== What third-party libraries does crashrpt use internally? ==

This depends on what CrashRpt version you use. See the documentation distributed with your version of CrashRpt.

Generally, CrashRpt may use the following libraries:

  * WTL -- Used for GUI management http://sourceforge.net/projects/wtl/
  * Microsoft Debug Help Library -- Used for creating crash minidumps http://msdn.microsoft.com/en-us/library/ms679309%28VS.85%29.aspx
  * TinyXml -- Used for creating and editing XML files http://www.grinninglizard.com/tinyxml/
  * ZLib -- File compression functionality  http://www.zlib.net/
  * zip utils -- ZIP file management  http://www.codeproject.com/KB/files/zip_utils.aspx
  * minizip -- ZIP file management (replacement for zip_utils)  http://www.winimage.com/zLibDll/minizip.html
  * libpng -- PNG file management  http://www.libpng.org/pub/png/libpng.html 

== Why should I use crashrpt in my Visual C++ project? ==

If you have ever tried to determine the reason of a crash on user's machine, you might know how difficult it is when you have user's directions only: "I opened something, then I clicked something and then it stopped working". Most of users won't contact you to tell about the problem and just give up using the program after several crashes. Users who decide to report the problem might not have technical knowledge, so it is difficult to determine the reason of the problem based on their instructions. This makes debugging remote crashes almost impossible, except in the simplest situations. That's why it is important to use special tools to report errors automatically.

== What are the main features of crashrpt? ==

  * CrashRpt is an open-source exception handling, reporting and post-processing library. It is designed for Windows applications written using Microsoft Visual C++. CrashRpt is able to intercept unhandled SEH exceptions, typed C++ exceptions and C run-time error.

  * CrashRpt can send error reports not only using HTTP, but also using E-mail. This is suitable for developers not having servers for storing error reports. To send reports over E-mail, user machine should have a mail program installed, for example Mozilla Thunderbird or Microsoft Outlook.

  * CrashRpt has a tool for error reports' post processing. The tool may be useful when you receive hundreds of reports a day and need to process them all at once (although the tool can't replace the human completely).

== What programming languages can I use crashrpt in? ==

You can use CrashRpt in C++ programs created using Visual C++. You can not use it in .NET or in Visual Basic. 

== What is an exception? ==

An exception or a critical error typically means that a program stops working normally and needs to stop its execution.

For example, an exception may occur because of the following:

  * program accesses an invalid memory address (such as NULL pointer)
  * stack is overflown due to infinite recursion
  * large block of data is written to a small buffer
  * a pure virtual method of a C++ class is called
  * memory buffer can't be allocated (out of memory)
  * invalid parameter is passed to a C++ system function
  * C++ run time libraries detect an error and request program termination

== Where can I find the latest version of crashrpt? ==

The latest version of CrashRpt can be found at [http://code.google.com/p/crashrpt/downloads/list Downloads] page. For the list of changes, see WhatsNew.

== I can't find the answer to my crashrpt-related question in this FAQ. What do I do? ==

You can sign in using Google account and add a comment for this wiki page. Or you can ask a question using our [http://groups.google.com/group/crashrpt Discussions group] (Google account is also required).

== How do I report a bug in crashrpt or request a new feature? ==

You can create an issue at our [http://code.google.com/p/crashrpt/issues/list Issues] page. We appreciate your feedback. Note that creating an issue requires you to be signed in using Google account.

== I found a bug in crashrpt or in `CrashSender.exe` (it crashes itself :)) and want to debug it in Visual C++ to determine the reason of the problem. What to I do? ==

Its easy to run `CrashRpt.dll` code in step-by-step debugging mode. Just trigger an exception in the application. But there may be a problem if Visual C++ doesn't allow you to debug after exception had occurred. To workaround this, generate error report manually without exception, using `crGenerateErrorReport()` function. This way you should be able to debug.

If the code in `CrashRpt.dll` works fine, but `CrashSender.exe` crashes, you need to attach to `CrashSender.exe` process when it is launched. In Visual C++ window, open `Debug | Attach to process...` menu and select `CrashSender.exe` in the list of processes. Then you will be able to run the code in step-by-step debugging mode.

== How do I contribute into crashrpt project development? ==

First of all create a topic in our [http://groups.google.com/group/crashrpt Discussions] group and describe there how you would like to contribute. Then we will add your email to the list of project members and you will be able to make changes in the source code.

== How can I show my appreciation of crashrpt project? ==

If you like CrashRpt and use it in your software product, you can show your appreciation and add your project name and logo to the WhoUsesCrashRpt page. By doing this you make CrashRpt more significant for other users and also support further development.

== Are there any analogous software for crash reporting? ==

Yes, they are listed in the table below:

|| *Name* || *Description* || *Link* ||
|| google-breakpad || An open-source multi-platform crash reporting system || http://code.google.com/p/google-breakpad/ ||
|| Mozilla Firefox Crash Reporting System || Used in Mozilla Firefox browser || https://developer.mozilla.org/en/Crash_reporting ||
|| Windows Error Reporting || Embed into Windows Vista and later || http://msdn.microsoft.com/en-us/isv/bb190483.aspx ||
|| `BugCollect.com` || Web-based crash reporting system || http://bugcollect.com ||
|| `BugTrap` || Crash reporting system for C++ and .NET || http://www.codeproject.com/KB/applications/BugTrap.aspx ||
|| `XCrashReport` || XCrashReport : Exception Handling and Crash Reporting  || http://www.codeproject.com/KB/debug/XCrashReportPt4.aspx ||


= Using crashrpt =

== What Visual C++ versions can I use crashrpt in? ==

You can compile CrashRpt in Visual C++ .NET 2003, Visual C++ 2005, Visual C++ 2008 and in Visual C++ 2010. Visual C++ 6.0 is not supported.

You can also compile CrashRpt in Visual C++ Express Edition. For additional info on compiling CrashRpt in VC++ Express, see below.

== How do I compile crashrpt in Visual C++ Express Edition? ==

In order to compile CrashRpt in Visual C++ Express Edition, you have to download and install `Microsoft Windows Server 2003 SP1 Platform SDK`, for example from [http://www.microsoft.com/downloads/details.aspx?FamilyId=A55B6B43-E24F-4EA3-A93E-40C0EC4F68E5&displaylang=en this place].

In VC++ Express window, open menu `Tools->Options...->Projects and Solutions->VC++ Directories`. In the 'Show directories for' combo, select 'Include files' and then add `[Platform_SDK_Folder]\Include\atl` path to the list of include directories ([Plaform_SDK_Folder] should be replaced with actual folder name). 

Note: In VC++ 2010 Express, there is no usual VC++ Directories page. Instead, open the Property Manager window, multi-select all projects and right click the selection. In the appeared dialog, open `Configuration Properties->VC++ Directories`. In the `Include Directories` field, add `[Platform_SDK_Folder]\Include\atl` path. 

That's all. Now you are be able to compile CrashRpt.

== Why do I have to install Platform SDK for Windows Server 2003 to be able to compile crashrpt in Visual C++ Express? ==

This is because CrashRpt depends on WTL library, which in turn depends on Microsoft's ATL library. 

ATL library is a part of Visual Studio SDKs. The latest version at the moment is ATL 8.0. An older version, ATL 3.0 is also included into Microsoft Platform SDK for Windows Server 2003. Since then, Platform SDK was renamed into Windows SDK and the latest version (at the moment) of Windows SDK is v6.0. However, Microsoft didn't include ATL into Windows SDK v6.0 to encourage using of commercial Visual Studio having ATL. The dependency on ATL introduces a lot of problems for WTL, so in the future WTL developers might remove this dependency at all (if possible).

For additional info on using WTL with VC++ Express, see this [http://www.codeproject.com/KB/wtl/WTLExpress.aspx article].

== Where do I look for VC++ Directories in Visual C++ 2010? ==

In VC++ 2010, there is no usual VC++ Directories page. Instead, you open the Property Manager window, multi-select all projects and right click the selection. In the appeared dialog, open `Configuration Properties->VC++ Directories`. In the `Include Directories` field, add `[Platform_SDK_Folder]\Include\atl` path. 

== What platforms crashrpt can be compiled for? ==

Since v1.2.1, CrashRpt can be compiled for both 32-bit (Win32) and 64-bit (x64) platforms. Earlier versions supported Win32 platform only.

== Where do I look for crashrpt documentation? ==

In the newest version of CrashRpt, the documentation is included into the CrashRpt release package. To open the documentation, click the `index.html` in the top level directory of the CrashRpt package. Online documentation for the latest CrashRpt version is also available here: [http://crashrpt.sourceforge.net/ Online Documentation].

In an older version, CrashRpt v1.0, the documentation can be found in [CrashRpt_v1_0_Documentation] page and also in [http://www.codeproject.com/KB/debug/crash_report.aspx http://www.codeproject.com/KB/debug/crash_report.aspx] article.

== How do I properly install crashrpt? ==

This depends on CrashRpt version you use. Typically, you download and unzip CrashRpt archive and then follow installation instructions listed in the documentation.

== How does crashrpt support multi-lingual user interface? ==

Since v.1.1.3, CrashRpt supports multi-lingual user interfaces. You can download a language file from here http://crashrpt.googlecode.com/svn/lang_files/ 

You should place a valid language file named `crashrpt_lang.ini` to the directory where `CrashSender.exe` file is located in order to make CrashRpt work properly. The language file is a text document in UNICODE format and having INI extension. The language file contains localized strings used by CrashRpt dialogs.

If your software supports several languages, you can distribute several language files with your software. On install, rename an appropriate file to `crashrpt_lang.ini` and copy it to the folder where your `CrashSender.exe` is located.

== How do I contribute a language file? ==

If there is no language file for your favorite language, you can contribute one. Also, if you see that there are some mistakes in an existing language file, you may want to improve it and then contribute your changes. 

For instructions, see ContributingLanguageFiles page.

== How does crashrpt work internally? ==

CrashRpt consists of two core modules: `CrashRpt.dll` and `CrashSender.exe`.
`CrashRpt.dll` contains functionality for intercepting exceptions in a client software.
`CrashSender.exe` contains functionality for compressing and sending error reports to the software's support team.

It is unsafe to do complex operations in the crashed program which may be unstable. CrashRpt is separated into these modules to be able to close the application which have crashed and to continue sending the error report in `CrashSender.exe` in background. 

Typically a process (executable file) loads `CrashRpt.dll` into its address space when process starts. This single instance of CrashRpt is shared between all DLL modules that are loaded into the address space of the process. Client application uses CrashRpt API functions to set exception handlers in the process once, typically in its `main()` function. In a multi-threaded program, client additionally sets exception handlers in the beginning of thread procedure of each worker thread.

== What .h file should I include in my code and what .lib file should I link my code to? ==

Include `CrashRpt.h` header file in the beginning of your code.

{{{
  // Include CrashRpt header
  #include "CrashRpt.h"
}}}

You also need to add `CrashRpt.lib` to the list of input libraries for your project. In the Solution Explorer window, right-click your project and choose Properties item in the context menu. Then open `Configuration Properties->Linker->Input->Additional Dependencies` and then add `CrashRpt.lib` to the list of libraries.

== How is crashrpt.dll loaded and how is it shared between other modules loaded into process address space? ==

Typically your process (EXE) loads `CrashRpt.dll` into process address space when process starts. This single instance of CrashRpt is shared between all DLL modules that are loaded into the address space of the process.

== My software is not an EXE, but DLL. Can I use crashrpt in such case? ==

It would be better if the client process (EXE) take care of exception handling instead of your DLL.

You may try to install exception handlers in your `DllMain()` function, but typically you can't guarantee that the client process (EXE) won't install its own exception handlers above yours. And there might be some problems if the client process uses several worker threads that call functions from your DLL. In such case you would have to somehow install per-thread exception handlers too.

== How do I use crashrpt across process boundaries? == 

Each process loads its own copy of `CrashRpt.dll`. It is difficult to imagine how you can share single loaded instance of `CrashRpt.dll` between several processes. Currently CrashRpt doesn't support such possibility. 

== How do I use crashrpt in a multi-threaded application? ==

You should use CrashRpt API functions to set exception handlers in the beginning of thread procedure of each of your worker threads. Do not forget to unset handlers in just before exiting the thread procedure.

== Does using crashrpt affect performance of my application? ==

No, using CrashRpt doesn't affect performance of your application. CrashRpt doesn't perform any tasks in background and doesn't use additional memory. CrashRpt code is executed just when an exception is raised.

== Does using crashrpt make it easier for somebody to reverse engineer my code? ==

No, actually not. In order to use CrashRpt, you enable program database generation in Release configuration (/Zi compiler flag and /DEBUG linker flag) and this generates .PDB file for your project. PDB files contain information which can be used to reverse engineer your code, however you typically store such information locally and do not distribute it with your software release package. So, using CrashRpt doesn't affect the difficulty of reverse engineering your code. 

== How do I use crashrpt API functions that have character set dependent arguments? ==

All CrashRpt functions using character set dependent arguments have two versions of function name (multi-byte versions are A-suffixed and wide character versions are W-suffixed). For example, `crInstall()` function has two versions of function name: `crInstallA()` and `crInstallW()`. Typically you use a character set independent mapping of function name in your program, for example use `crInstall()` that expands into `crInstallW()` if you use wide character set or into `crInstallA()` if you use multi byte character set.

== Why would I want to add a custom file to the error report? == 

If your application creates and maintains a log file where operations and errors are written, then such log file might be helpful for crash analysis and should be added to the error report. 

== Why would I want to add a screen shot to the error report? ==

It may be useful to have a screen shot of user's desktop at the moment of crash. This may help to see which button user clicked before the crash, and to see the desktop state. Sometimes it may be enough to see only the region of the desktop occupied by your application and not the rest of desktop.

But there is one thing to take in account. By enabling screen shot capture, you should be careful about user's privacy. Some parts of the desktop screen shot may contain private or user identifying information: folder names, wallpapers, photos, text fragments and so on. That's why you should always provide a link to your Privacy Policy page describing what information you collect on crash and what purposes you use it for. For example, see PrivacyPolicyTemplate.

== Why would I want to add a custom text property to the crash description XML? ==

One way to add application-defined info to the error report is adding a custom file. But sometimes you may want to extend the crash description XML file by adding a custom named literal property to the XML file. You can do this through the `crAddProperty()` function.

For example, you may need to add the info about amount of free disk space on a specific disk drive at the moment of crash, or about the version of the graphics card driver installed on user's machine.

== Why would I want to add a registry key dump to the crash report? ==

If your application stores its settings as a registry key under `HKEY_CURRENT_USER` or `HKEY_LOCAL_MACHINE`, you may want to add the dump of the key to the crash report. Since v.1.2.6, you can do this with the help of the `crAddRegKey()` function.

== I want to uniquely identify the installation by what the error reports are sent. What do I do? ==

In CrashRpt v.1.2.1, we introduced a function `crAddProperty()` specially for purposes of extending the crash description XML as you wish. You can create the installation GUID in your program, store it in the registry or in a file and pass this GUID to the `crAddProperty()` function, so the named property will be added to the crashrpt.xml and 
you will be able to identify the installation and associate the bugs together.

The following code example shows how to do this (code provided by tdev):

{{{
  // ... upon program start, check if GUID is not existing, if not create one:
  GUID *g = new GUID();
  CoCreateGuid(g);
  
  char buf[120];
  sprintf( buf, "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
    g->Data1, g->Data2, g->Data3, UINT(g->Data4[0]), UINT(g->Data4[1]), UINT(g->Data4[2]), 
    UINT(g->Data4[3]), UINT(g->Data4[4]), UINT(g->Data4[5]), UINT(g->Data4[6]), UINT(g->Data4[7]));
  delete g;
  std::string guid = std::string(buf);

  //... later, add it to the crashreport:
  crAddProperty("SystemGUID", guid);
}}}

== We ship a software (game etc.) and certain crashes only happen on certain hardware. So we need some sort of functionality that gathers GPU/CPU/general hardware information upon crash report generation. What do we do? ==

We introduced a function `crAddProperty()` specially for purposes of extending the crash description XML as you wish. You can also use the `crAddFile2()` function, which allows to add a used-defined file to the crash report.

== Why would I want to generate error report without crash? ==

Sometimes it may be required to remotely debug some application logics error. Such an error, for example, infinite loop in a worker thread, may not cause program crash. To collect the information about such error, a software developer might provide an ability to generate error report manually on user demand, for example on a key combination press. 

== I would like to force the user to enter a description of what happened just before the crash. What do I do? ==

The user has an ability to enter the description of the problem in the main dialog (see the second link "Provide additional information (recommended)"). 

However, my CrashRpt usage experience shows most users do not enter anything meaningful into this field, some users just enter trash.

== What do I do to save a local copy of an error report to my disk? ==

Since v.1.2.2, you can use the 'Export...' button on the Error Report Details dialog to save a local copy of the error report. 

== Does crashrpt support a non-GUI (silent) mode? ==

Yes, since v.1.2.2, CrashRpt supports non-GUI mode. In the non-GUI mode, CrashRpt doesn't show any windows and sends the report without any user interaction. You can use such mode if your application is a service which has no GUI and usage of crash reporting is still desired.

However, it is not recommended to use the non-GUI mode with regular GUI applications which create windows and interact with user.

== Does crashrpt support automatic restart of the application that crashes? ==

Yes, since v.1.2.4, CrashRpt supports automatic application restart. But the restart is performed if two conditions are satisfied: 
  * If at least 60 seconds have elapsed since the application start. This is done to avoid cyclic restarts in case when crash occurs on application start up.
  * If the user has provided his consent to restart the app. 

== What is the recommended way of CRT linkage for crashrpt to work properly? ==

It is recommended that you configure your project to use C runtime libraries (CRT) as `Multi-threaded DLL (/MD)` for `Release` configuration. This is the way recommended in MSDN. 

In the Solution Explorer window, right-click your project and open project Properties. Then choose `Configuration Properties->C/C++->Code Generation`. In the `Runtime Library` field, choose `Multi-threaded DLL (/MD)`.

This should be done for all projects in your solution to ensure all modules will share single CRT DLL.

== What do I do if modules of my application use different versions of CRT? ==

Ensure that all modules that exist in your application use the same version of CRT. If some dependent modules were compiled using an older version of CRT, you should recompile them to ensure the single version or CRT DLL is used.

For example, assume you use Visual Studio 2005 and CRT 8.0 linked as DLL, but some dependent module in your application was compiled in Visual Studio .NET 2003 and uses CRT 7.1 linked as DLL. In such situation a CRT error in the dependent module won't be intercepted by CrashRpt, because CrashRpt will intercept exceptions in CRT 8.0 only. However, CrashRpt will intercept SEH exceptions in all modules not depending on CRT version.

== What do I do if my project uses CRT as a static library? ==

You can try to compile CrashRpt in `Release LIB` configuration. This configuration is experimental and may be removed in future versions.

Actually, it is recommended that you configure your project to use C runtime libraries (CRT) as `Multi-threaded DLL (/MD)` for `Release` configuration. This is the way recommended in MSDN. And you may have troubles if CRT is used in different way. Below is explained why CRT DLL is better than the static LIB.

Each module (EXE, DLL) in your project is linked to CRT (C runtime libraries). You may link CRT as multi-threaded static library or as multi-threaded dynamic link library (DLL). When you set CRT error handlers, such as pure call handler or invalid parameter handler, they will work for the CRT the caller module is linked to and won't intercept exceptions in different CRT modules (if exist).

Several project modules may share single CRT DLL. This reduces to minimum the overall size of linked CRT code. And all exceptions within that CRT DLL can be handled at once. That's why multi-threaded CRT DLL is the recommended way of CRT linkage.

If your project uses CRT as a static link library (which is not recommended to do) and  you want to use some crash reporting functionality, you would have to compile the functionality as static a lib with `/NODEFAULTLIB` linker option. Then you would have to install CRT error handlers for _EACH_ module that your program loads into its address space. 

== Can I compile crashrpt as a static library? ==

It is not recommended to use CRT as a statically linked library. However, you can try to compile CrashRpt in `Release LIB` configuration. This configuration is experimental and may be removed in future versions.

== Why should I enable Program Database (/Zi) compiler flag and Generate Debug Info (/DEBUG) linker flag? ==

To get the most out of the crash minidump, the debugger needs your application's debug symbols. By default, Release builds don't generate debugging symbols. The crash minidump is unusable without the debugging symbols database (program database, PDB). 

  # In the `Solution Explorer` window, right-click your project and open project Properties window. Then choose `Configuration Properties->C/C++->General`. In the `Debug Information Format` field, choose `Program Database (/Zi)`.
  # Choose `Configuration Properties->Linker->Debugging`. In the `Generate Debug Info` field, choose `Yes (/DEBUG)`. In the Generate Program Database File` field, enter the name for your PDB file.

These steps should be done for all projects in your solution that support program database (EXE, DLL).

== Should I use rebase.exe to set preferred load address for modules of my application to be able read minidumps later? ==

This is not necessary, because a minidump file itself contains the list of loaded modules of your application and their actual load addresses. 

== Does crashrpt intercept _exactly_ all exceptions that may occur in my program? == 

CrashRpt intercepts all exceptions that are allowed to intercept by C runtime libraries (CRT).

Note that some exceptions related to security can't be intercepted. Since CRT 8.0 you can't intercept security errors in your code. When buffer overrun is detected, CRT invokes Dr.Watson directly instead of calling unhandled exception filter. This is done because of security reasons and Microsoft doesn't plan to change this behavior.

For more information, see this [https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=101337 link].

== How do I test if crashrpt intercepts exceptions in my application? ==

When you install crash reporting support to your program, it is important to test if CrashRpt intercepts exceptions properly. Use `crEmulateCrash()` function to emulate an exceptional situation. Call this function in your `main()` function and in the thread procedure of each of your working threads.

== Do program optimizations (/O compiler switch) affect the minidump generation? ==

Yes, if you enable optimizations, the stack trace recovered from minidump may be incomplete (e.g., see issue 25). However, this is not the reason to turn the optimizations off. Instead, you can manage some error log file which is not affected by optimizations.

== What is the minidump type? What minidump type should I use? ==

The minidump type defines what information is contained in the minidump. The default minidump type is `MinidumpNormal`. However, the `MinidumpNormal` contains only essential info required to recover the stack traces for each thread. To recover the state of global variables, other minidump types should be used. For additional info, see the [http://www.debuginfo.com/articles/effminidumps.html Effective Minidumps] article.

== What files do I save locally before my software is released? ==

When you are ready for a software release, the following steps must be performed to be able to properly read the error reports received from end-users:

    * Create a directory, for example name it `CrashRptSaved`.
    * In that directory create a subdirectory for your software release, for example `MyApp v.1.3.5`.
    * Copy all binary files (.EXE, .DLL) from your project output.
    * Copy all program database files (.PDB) from your project output.
    * Copy your source code files. If you use a version control systems (for example, SVN), create a tag for the current code revision.

These steps should be performed for exactly the same software build that you plan to release. If you rebuild the project after files are copied, you must copy the files again.

When a crash report comes in, you use the release binaries, source code and debug symbols you saved, along with the minidump included in the crash report, to debug the crash.

== I use a packer for my EXE or DLL (e.g. PECompact, UPX and so on). How does this affect the way I read the generated minidump file? ==

You can use a compression utility for reducing the size of your executable or DLL, but be careful of the following. 

In order to read the minidump, you need to save a local copy of the uncompressed EXE (DLL) file and a PDB file generated for that EXE (DLL). You also need to have the source code that you used when building the EXE (DLL). These should be enough to read the minidump generated by the compressed version of your EXE. 

== I sign my EXE with a digital certificate (Authenticode). How does this affect the way I read the generated minidump file? ==

You can use an Authenticode utility for signing your executable, but be careful of the following. 

In order to read the minidump, you need to save a local copy of the unsigned EXE file and a PDB file generated for that EXE. You also need to have the source code that you used when building the EXE. These should be enough to read the minidump generated by the signed version of your EXE. 

== I need to edit a resource embedded into my compiled EXE (DLL) binary (e.g. I need to upgrade its version). How this affects the way I read the generated minidump file? ==

You can edit resources in your compiled binaries, but be careful of the following. 

In order to read the minidump, you need to save a local copy of the original (unmodified) EXE (DLL) file and a PDB file generated for that EXE (DLL). You also need to have the source code that you used when building the EXE (DLL). These should be enough to read the minidump generated by the resource-modified version of your EXE (DLL). 

== I use `IncrediBuild` for compiling my project. Does crashrpt work with PDB files generated such way? ==

Yes, CrashRpt works with PDB files generated with help of `IncrediBuild`.

[http://www.xoreax.com/ IncrediBuild] is a platform for accelerating Visual C++ builds through by distributing the build processes over local area network.

== What files should I never distribute with my software release package? ==

  * All binaries (EXE, DLL) and program database files (PDB) compiled in `Debug` configuration SHOULD NOT be distributed as they will not only take up more space on your CD/download/client's machine, but they will also make reverse engineering your code a trivial exercise.
  * The program database files (PDB) generated in `Release` configuration SHOULD NOT be distributed because of they may make it easier to reverse engineer your code. 

== What crashrpt files do I distribute with my software release package? == 

The list of files you should distribute depends on your version of CrashRpt. 

Not depending on version, it is recommended that you distribute the following files with your software release:

    * `CrashRpt.dll` 
    * `CrashSender.exe` 
    * `dbghelp.dll` 
    * `crashrpt_lang.ini`
    
It is recommended that you place these files to the directory where your application executable file is located.

The `CrashRpt.dll` and `CrashSender.exe` are core CrashRpt modules. `dbghelp.dll` (Microsoft Debug Help Library) is the module CrashRpt depends on. `crashrpt_lang.ini` is the language file.

== I know that dbghelp.dll is shipped with Windows. Why should I distribute it? ==

It is recommended that you distribute `dbghelp.dll` with your software, because some end-user machines may not have `dbghelp.dll` installed or `dbghelp.dll`'s version may be different on different user machines.

`dbghelp.dll` presents in Windows XP and later, so most user machines have this library installed. If your target OS is Windows XP and later, you may ignore distribution of `dbghelp.dll` at your own risk. 

== I do not like that I should distribute all these DLLs. Can I compile them all as static libs? ==

No, this is impossible. Architecture of CrashRpt requires two modules: `CrashRpt.dll` and `CrashSender.exe`. You may ignore distribution of `dbghelp.dll`, but a end-user's operating system may not have `dbghelp.dll` installed. So, you have to distribute all these binaries.

= Error Reports Creation and Delivery = 

== What is an error report? ==

An error report refers to a collection of files intended to help the developer diagnose the cause of a crash.

The error report contains crash minidump file (crashdump.dmp), which has operating system version, processor type, CPU registers state and local variables and stack trace for each execution thread. The minidump can be used on developer's side to determine the reason of the crash and try to fix the problem.

In addition, CrashRpt generates XML crash description file. The file contains various complementary information that might be useful for crash analysis.

Crash report can optionally contain application-defined files, for example, application log files, included into crash report via the crash callback. 

== How does crashrpt create an error report when crash occurs? ==

When crash occurs, CrashRpt runs another process named `CrashSender.exe`. The parent process is then terminated. If you generate error report manually, the parent process is not terminated.

CrashRpt saves the error report files to `LOCAL_APP_DATA\CrashRpt\UnsentErrorReports\AppName_AppVersion` folder. 

== What is the Privacy Policy? Where can I find a template for the Privacy Policy? ==

Since v.1.1.2, you can use a privacy policy which describes what user information your software collects on crash. You provide the URL of your privacy policy document, which you may publish on your web site or distribute with your software. 

If you need a template you may use this one: PrivacyPolicyTemplate.

== How does crashrpt deliver me error reports from end users? ==

CrashRpt sends error reports back to your software support team using any of the following ways:
  * via HTTP request to a server-side script
  * via connection to an SMTP server
  * via Simple MAPI programming interface (the user's default E-mail client application is being utilized)

If one of these ways fails, CrashRpt tries others in turn. You can define the preferred order of ways used to send reports.

== Are there any crash report size limitations? ==

Yes, they are. Although CrashRpt supports large error reports, the crash report should be as small as possible. If you use E-mail for error reports delivery, there may be mail size limits on the SMTP server. If the error report is larger than the limit, it is possible that the error report will be rejected. If you use HTTP for error report delivery, there may also be POST data size limits on the web-server. You should check your web-server settings to figure out the maximum error report size.

== How does crashrpt send me error reports using HTTP connection? ==

Many software products have web sites on the Internet. Such web servers typically have some scripting engine enabled, for example PHP, Perl, ASP and so on. CrashRpt can establish HTTP connection to the server and send an error report as a script parameter.

This way is not affected by firewalls, because most firewalls have HTTP port 8080 open. However, this way requires a server with some script that you create and deploy yourself.

See CrashRpt project documentation for more information.

== How does crashrpt send me error reports using SMTP connection? ==

CrashRpt has a simple built-in SMTP client. It can try to send an error report to recipient using SMTP connection without any user interaction. The error report is sent as an E-mail multi-part message with attachments.

This way `CrashSender.exe` creates SMTP connection with a mail server (port 25) and sends crash reports without additional user interaction. There are two SMTP servers that can be used to relay email: sender's mailbox and recipient's mailbox. 

If user provides his/her email address, CrashRpt tries to use the address's MX domain record to determine local SMTP server name and relay the email message to that server.

If user doesn't provide his/her email address, CrashRpt tries to send the email directly to recipient using the MX record of recipient's domain. Many SMTP servers may block direct access to them to avoid spam (for example Google does so).

This way won't work when firewall is enabled and port 25 is closed for outbound traffic (SMTP client won't be able to even connect). Since many organizations and even home users have firewalls that silently block port 25, this way fails for many users. 

== How does crashrpt send me error reports using Simple MAPI programming interface? ==

CrashRpt can use the default E-mail client, for example, Mozilla Thunderbird, to send the error report as email. The error report is sent as E-mail multi-part message. This requires some user interaction. This way has the lowest priority by default. 

== What does crashrpt do when all attempts to send error report fail? == 

When all attempts fail, `CrashSender.exe` saves error report files to the `LOCAL_APP_DATA\CrashRpt\UnsentErrorReports\AppName_AppVersion` folder and shows the status notification window. 

= Using Error Reports =

== What do I do when I start receiving error reports after software release? ==

When software release is made and CrashRpt support is enabled in your software, sooner or later you start receiving crash reports.

Count of received crash reports may depend on robustness of your software to various exceptional situations and on how much your software popular. So it's nothing unusual if you receive hundreds of error reports a day. If there are many incoming error reports, you can monitor and analyze them for the first few days after release, and prepare a hot fix release.

The purpose of an error report is to help you determine the reason of the problem and try to fix it. The keyword is 'try', because in most cases you can't fix crash reports as you usually do with normal bugs. You usually can't reproduce the error on your machine, so you can't guarantee it is fixed. So the only way to check is to make fixes in parts of code that could cause the crash most probably and to release a new version of software.

The normal scenario is that your software becomes more and more stable with each release and less and less error reports are received.

== How do I check integrity of a received error report?  ==

You may calculate MD5 hash for your error report and compare it with the MD5 hash that is attached to the error report. 

When you receive error reports using HTTP connection, the MD5 hash is passed to the server-side script through the 'md5' parameter. 

Since CrashRpt v1.1.1., when you receive error reports using email, the MD5 hash is attached to the email.

== How do I use an error report for debugging a crash? ==

A crash report is a ZIP file containing several files, such as crash minidump (crashdump.dmp), crash description XML (crashrpt.xml), and optional application-specific files, e.g. , application log files.

The crash description is an XML file that contains the basic information about the crash,
for example exception type, operating system name, application name and version.
 
The crash dump file is a collection of memory ranges, CPU register states, the call stack and local variables for each execution thread, the list of loaded and unloaded modules and system information. You can open the minidump in your Visual Studio or in `WinDbg` program and see the place of your code where exception had occurred. 

See CrashRpt documentation more information.

== Does crashrpt support bidirectional communication (the user gets an email with updates on his issue)? ==

We currently do not support bidirectional communication, because this would require some complex server-side functionality. You can add such integration on your server for users of your software yourself if you wish. 

== How do I open a crash description XML file? ==

You can use notepad, another text editor or your web browser.

== What is crash GUID? ==

A crash description XML contains `CrashGUID` tag. The crash GUID is an unique identifier that is assigned to the error report. GUIDs are generated using special algorithm which guarantees very low probability of generating the same GUID twice, even on different user machines. The crash GUID can be used, for example, as the primary key if you plan to store crash reports in a database.

== How do I determine the name and version of the application that generated the error report?  ==

The crash description XML file contains `AppName` and `AppVersion` tags. You use them to determine what application sent you the report. You are typically interested in analyzing error reports from the latest version of your software and ignore reports from older versions.

== How do I determine the OS version for the error report? ==

A crash description XML contains `OperatingSystem` tag which is the friendly name of end user's operating system, including name, build number and service pack. It is useful information because many errors are OS-specific.

== What is an `ExceptionType` tag in the crash description XML? ==

The exception type shows what exception handler caught the exception. For example, type 0 means that the SEH exception was intercepted by the unhandled exception filter set with `SetUnhandledExceptionFilter()` function. The exception type can be used to divide exceptions in some categories. 

See the documentation for more information about exception type.

== How do I open a crash minidump file (.DMP)? ==

In order to open the crash minidump, copy it to the directory where the binaries (EXE, DLLs) and program database files (PDB) are locally stored. You copy the minidump to this folder to ensure the debugger finds the program database files and binaries. 

Then double-click on the minidump file name. This should open it using an associated program (for example, Visual Studio). When minidump file is loaded in Visual Studio, press F5 to run it. If debug symbols are loaded successfully, you are now able to see the place in your source code where exception had occurred.

Alternatively, you can open the minidump file using `WinDbg` program from `Microsoft Debugging Tools`. It is freely distributed.

== How do I identify if the symbol files fit to a certain executable? ==

Symbol files are identified by timestamps (in older versions of PDB) or by GUIDs (in newer versions of PDB). 

You do not need to identify matching PDB yourself. Symbol handler will do that for you. Just specify the list of folders to search in and the symbol handler will look for correct PDB files itself. 

== If I've saved all the source code, should building from the source recreate the correct PDBs and use them for reading the minidump? ==

No, the recreated PDB files will not be the same as the original ones. The recreated PDB files won't have matching time stamp (or GUID in a never versions of dbghelp). The building environment may also be different, so generated binaries may be different.

The recommended way is to save the original PDB files (that were produced when building the project), binary files (EXE and DLL) along with the source code. 

== I open minidump, but symbols are not loaded. What do I do? ==

Sometimes you can't determine the location of the crash and the error message is displayed 'No symbols loaded for any stack frame'. This may be because of the following reasons.

  * Debugger may not locate the correct PDB and binary files. Try to open `Tools->Options->Debugging->Symbols` and enter the path to the directory where your PDB files are located. Then reopen the minidump.

  * You have wrong or missing PDB files. Open the Modules window and check the symbol status for modules of your program. If the status is 'Not loaded' than you have missing PDB. Or maybe correct PDB files weren't saved locally before software release. In such case you won't be able to properly read any of received crash reports.

  * If symbols for some modules of your program are loaded, and you have the error, than there were no debugging symbols generated for the module where crash had occurred. Check that you set `Program Database (/Zi)` compiler flag for all modules of your application.

== How do I automate crash report processing? ==

Automating the error report processing becomes the critical task when you receive a lot of error reports after software release. Among hundreds of reports there may be only several different problems, while others just duplicate the information about these problems. Opening so many reports manually in Visual Studio or in `WinDbg` and analyzing their content may become boring and take a lot of time.

Since v1.2.0, CrashRpt provides a way for automating the report processing. The command line tool named `crprober.exe` is introduced for processing error report files and outputting the results to a text file or to terminal. The `CrashRptProbe API` is introduced to provide base crash report processing services to your custom error report processing applications.

== How do I use the `crprober.exe` tool? ==

Since v1.2.0, CrashRpt provides a tool named `crprober.exe` that can be used for automating crash report processing. To run the tool, go to `bin` directory and type `crprober.exe` in the command line. 

The tool can be used to open error report files generated by any version of CrashRpt. However it works the best with reports created by version 1.1 and higher.

For usage examples, please see the documentation.

== How do I calculate some statistics about processed error reports? ==

You can write some C++ program or for example Python script that would parse output text files and calculate the desired statistics. For example, see the SampleProcessingPythonScript provided by RoRThom.

== Is it possible to use crprober under Linux? with Wine? ==

crprober depends on `dbghelp.dll` (Microsoft Debug Help Library). I'm not sure if you can make it work under Linux/Wine. You can try and tell us if this work. However, I would recommend to use it under the native Windows.

== What is crashrptprobe API? ==

The `CrashRptProbe API` is the application programming interface for processing error reports generated by crashrpt. The API includes several functions you can use in your own error report processing tool. The API is used internally by the `crprober.exe` tool.

The error report processing functionality is encapsulated inside of `CrashRptProbe.dll`. Internally `CrashRptProbe.dll` uses functions provided by `dbghelp.dll` (Microsoft Debug Help Library) for loading the minidump file contained in the report.