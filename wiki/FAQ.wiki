#summary Frequently Asked Questions
#labels Featured,Phase-Deploy

<wiki:toc max_depth="2" />

= General Questions =

== What is crashrpt? ==

CrashRpt library is a light-weight error handling framework. The library will intercept a Win32 structured exception and a C++ exception generated by a user-mode application. CrashRpt DLL works like Dr. Watson utility that ships with Windows XP, or like Windows Error Reporting in Windows Vista. CrashRpt intercepts an unhandled exception, creates a minidump, builds a crash descriptor in XML format, presents an interface to allow user to review the crash report, and finally it compresses and sends the crash report to the software support team.

== What programming languages can I use crashrpt in? ==

You can use CrashRpt in C++ programs created using Visual C++. You can't use it in .NET or Visual Basic. 

CrashRpt is specific to Visual C++. It intercepts structured WIN32 exceptions that are Windows-specific and in theory can be intercepted in other languages, too. But also it intercepts C run-time libraries (CRT) errors. These errors are Visual C++ specific, other languages have different error handling mechanisms.

== What is an exception? ==

An exception or a critical error typically means that a program stops working normally and needs to stop its execution.

For example, an exception may occur because of the following:

  * program accesses an invalid memory address (such as NULL pointer)
  * stack is overflown due to infinite recursion
  * large block of data is written to a small buffer
  * a pure virtual method of a C++ class is called
  * memory buffer can't be allocated (out of memory)
  * invalid parameter is passed to a C++ system function
  * C++ run time libraries detect an error and request program termination

== Why should I use crashrpt in my Visual C++ project? ==

CrashRpt provides functionality to properly handle structured Win32 exceptions, C++ runtime libraries (CRT) errors and C++ interruption signals. It would take a lot of efforts from you to implement this yourself. CrashRpt collects all information you need to debug the problem. CrashRpt can deliver error reports using HTTP request, SMTP connection and through Simple MAPI. In addition, CrashRpt is well documented, so its easy to start using it in your project.

== What is current crashrpt project status? ==

The latest version of CrashRpt is v1.1.3. For the list of changes, see [CrashRpt_v1_1_3_ReleaseNotes].

An older version, CrashRpt v1.0 is declared deprecated and not recommended for download.

== How can I show my appreciation of crashrpt project? ==

If you like this project and use it in your software product, you can show your appreciation and add your project name and logo to the WhoUsesCrashRpt page. By doing this you make CrashRpt more significant for other users and support further development.

== How do I report a bug in crashrpt or request a new feature? ==

You can create an issue in our issue tracker http://code.google.com/p/crashrpt/issues/list. We appreciate your feedback. 

Note that creating an issue requires you to be signed in using Google account.

== How do I contribute into crashrpt project development? ==

You can create a topic in crashpt group http://groups.google.com/group/crashrpt and describe there how you would like to contribute. After that project owner will add your email to the list of project members and you will be able to make changes in source code.

== Are there  any analogous software for crash reporting? ==

Yes, they are listed in the table below:

|| *Name* || *Description* || *Link* ||
|| google-breakpad || An open-source multi-platform crash reporting system || http://code.google.com/p/google-breakpad/ ||
|| Mozilla Firefox Crash Reporting System || Used in Mozilla Firefox browser || https://developer.mozilla.org/en/Crash_reporting ||
|| Windows Error Reporting || Embed into Windows Vista and later || http://msdn.microsoft.com/en-us/isv/bb190483.aspx ||



= Using crashrpt =

== What Visual C++ versions can I use crashrpt in? ==

Since v1.1b of CrashRpt you can use CrashRpt in Visual C++ .NET 2003, Visual C++ 2005 and Visual C++ 2008. Visual C++ 6.0 is not supported anymore.

Since v1.1.1 of CrashRpt you can compile and use CrashRpt in Visual C++ Express Edition (EVC++ 2005 and EVC++ 2008). For additional info on compiling CrashRpt in VC++ Express, see below.

== How do I compile crashrpt in Visual C++ Express? ==

CrashRpt depends on WTL library. First of all, download the latest version of WTL from here http://sourceforge.net/projects/wtl/ WTL is an open source project which constantly evolves and adapts to new versions of Visual Studio (including VS Express). The latest version at the moment is WTL 8.1.

Unzip WTL archive to any folder. In VC++ Express window, open Tools->Options...->Projects and Solutions->VC++ Directories. In the 'Show directories for' combo, select 'Include files' and then add WTL\include path to the list of include directories.

WTL itself depends on Microsoft's library called ATL (Active Template Library). ATL library is a part of Visual Studio SDKs. The latest version at the moment is ATL 8.0. An older version, ATL 3.0 is also included into Microsoft Platform SDK for Windows Server 2003. Since then, Platform SDK was renamed into Windows SDK and the latest version (at the moment) of Windows SDK is v6.0. However, Microsoft didn't include ATL into Windows SDK v6.0 to encourage using of commercial Visual Studio having ATL. The dependency on ATL introduces a lot of problems for WTL, so in the future WTL developers might remove this dependency at all (if possible).

Download and install Microsoft Platform SDK for Windows Server 2003, for example from here http://www.microsoft.com/downloads/details.aspx?FamilyId=A55B6B43-E24F-4EA3-A93E-40C0EC4F68E5&displaylang=en, since it is the only Platform SDK that supports ATL.

In VC++ Express window, open Tools->Options...->Projects and Solutions->VC++ Directories. In the 'Show directories for' combo, select 'Include files' and then add `[Platform_SDK_Folder]\Include\atl` path to the list of include directories.

That's all. Now you are be able to compile CrashRpt.

For additional info on using WTL with VC++ Express, see http://www.codeproject.com/KB/wtl/WTLExpress.aspx

== How do I properly install crashrpt? ==

* Downloading *

Download the latest stable version of CrashRpt from the [http://code.google.com/p/crashrpt/downloads/list Downloads] page. Unzip the archive to any folder.

You also need to download the latest version of WTL from here http://sourceforge.net/projects/wtl. Unzip the WTL archive to some folder. In Visual Studio, open Tools-> Options->Projects and Solutions->VC++ Directories. In the 'Show directories for' combo select 'Include files', then add the path to WTL\include directory to the list below.

* Compiling *

By default CrashRpt release package already contains binary files compiled with Visual Studio 2005 in its `bin` directory. However, it is strongly recommended that you compile CrashRpt yourself using your version of Visual Studio.

To compile CrashRpt yourself follow the following steps:

   # Open one of solution files available in the top level directory of CrashRpt package, depending on your version of Visual Studio:
          * `CrashRpt_vs.NET.sln`
          * `CrashRpt_vs2005.sln`
          * `CrashRpt_vs2008.sln`
   # Choose the `Release` build configuration and press `F7` to build the solution.

* Include and Lib directories *

It is recommened that you let the Viual C++ compiler know about CrashRpt using the following steps:

In Visual Studio window, open Tools->Options->Projects and Solutions->VC++ Directories.

    * In the 'Show directories for' combo select 'Include files', then add the path to `[CRASHRPT_HOME]\CrashRpt\include` directory to the list below.
    * In the 'Show directories for' combo select 'Library files', then add the path to `[CRASHRPT_HOME]\lib` directory to the list below.
    * In the 'Show directories for' combo select 'Executable files', then add the path to `[CRASHRPT_HOME]\bin` directory to the list below.

Here `[CRASHRPT_HOME]` should be replaced with the actual path of the directory you unzipped CrashRpt package to.

== What third-party libraries does crashrpt use internally? ==

CrashRpt uses the following libraries:

|| *Name* || *Description* || *Link* ||
|| WTL || Used for GUI management || http://sourceforge.net/projects/wtl/ ||
|| Debug Help Library || Used to create crash minidumps || http://msdn.microsoft.com/en-us/library/ms679309%28VS.85%29.aspx || 
|| TinyXml || Used to create and edit XML files || http://www.grinninglizard.com/tinyxml/ ||
|| ZLib || Used to create ZIP archives || http://www.zlib.net/ ||
|| zip utils || Makes using ZLib easier || http://www.codeproject.com/KB/files/zip_utils.aspx || 

== Where do I look for crashrpt documentation? ==

In the newest version of CrashRpt, the documentation is included into the CrashRpt release package. To open the documentation, click the `index.html` in the top level directory of the CrashRpt package.

In an older version of CrashRpt v1.0, the documentation can be found in [CrashRpt_v1_0_Documentation] wiki page and also in [http://www.codeproject.com/KB/debug/crash_report.aspx http://www.codeproject.com/KB/debug/crash_report.aspx] article.

== How does crashrpt support multi-lingual user interface? ==

Since v.1.1.3, CrashRpt supports multi-lingual user interfaces. You should place a valid
language file named `crashrpt_lang.ini` to the directory where `CrashSender.exe` file is located in order to make CrashRpt work properly. The language file is a text document in UNICODE format and having INI extension. The language file contains localized strings used by CrashRpt dialogs.

If your software supports several languages, you can distribute several language files with your software. On install, rename an appropriate file to `crashrpt_lang.ini` and copy it to the folder where your \b CrashSender.exe is located.

You can download a language file from here http://crashrpt.googlecode.com/svn/lang_files/ 

For example, assume you want to download the English language file for CrashRpt v1.1.3. Browse for `lang_files->1.1.3->crashrpt_lang_EN.ini` (shown below).

{{{
- lang_files
   - 1.1.3
       crashrpt_lang_EN.ini
}}}

== How do I contribute a language file? ==

If there is no language file for your favourite language, you can contribute one. Also, if you see that there are some mistakes in an existing language file, you may want to improve it and then contribute your changes. 

For instructions, see ContributingLanguageFiles.

== How do I use crashrpt in my Visual C++ project? ==

Go to the top level directory of CrashRpt package and click the index.html file to open project documentation. Then follow the directions in Using CrashRpt in Your Visual C++ Project page of the documentation.

== What .h file should I include in my code and what .lib file should I link my code to? ==

Include `CrashRpt.h` header file in the beginning of your code.

{{{
// Include CrashRpt header
#include "CrashRpt.h"
}}}

You also need to add `CrashRpt.lib` to the list of input libraries for your project. In the Solution Explorer window, right-click your project and choose Properties item in the context menu. Then open Configuration Properties->Linker->Input->Additional Dependencies and then add `CrashRpt.lib` to the list of libraries.

== How is crashrpt.dll loaded and how is it shared between other modules loaded into process address space? ==

Typically your process (EXE) loads `CrashRpt.dll` into process address space when process starts. This single instance of CrashRpt is shared between all DLL modules that are loaded into the process' address space.

It is enough to set exception handlers in the process once. No need to set handlers in each DLL's `DllMain()` function, because handlers work on per-process basis.

== My software is not an EXE, but DLL. Can I use crashrpt in such case? ==

Well, you can install exception handlers in your `DllMain()` function, but typically you can't guarantee that the client process (EXE) won't install its own exception handlers above yours. And there might be some problems if the client process uses several worker threads that call functions from your DLL. In such case you would have to somehow install per-thread exception handlers too.

It would be better if the client process take care of exception handling instead of your DLL.

== How do I use crashrpt across process boundaries? == 

Each process loads its own copy of 'CrashRpt.dll'. It is difficult to imagine how you can share single loaded instance of `CrashRpt.dll` between several processes. Currently CrashRpt doesn't support such possiblity. 

== How do I use crashrpt in a mutli-threaded application? ==

You should use CrashRpt API functions to set exception handlers in the beginning of thread procedure of each of your worker threads. Do not forget to unset handlers in just before exiting the thread procedure.

== Why does crashrpt consist of two modules: crashrpt.dll and crashsender.exe? ==

`CrashRpt.dll` contains functionality for intercepting exceptions in a client software. `CrashSender.exe` contains functionality for sending error reports to the software's support team. We've separated CrashRpt into these modules to be able to close the application which crashes and to continue sending error report through `CrashSender.exe` in background.

== Does using crashrpt makes it easier for somebody to reverse engineer my code? ==

Actually not. To use CrashRpt you enable program database generation in Release configuration (/Zi compiler flag and /DEBUG linker flag) and this generates .PDB file for your project. PDB file contains information that can be used to reverse engineer your code, however you typically store it locally and do not distribute with your software release package. So, using crashrpt doesn't affect the difficulty of reverse engineering your code. 

== How do I use crashrpt API functions that have character set dependent arguments? ==

All CrashRpt functions using character set dependent arguments have two versions of function name (multibyte versions are A-suffixed and wide character versions are W-suffixed). For example, `crInstall()` function has two versions of function name: `crInstallA()` and `crInstallW()`. Typically you use a character set independent mapping of function name in your program, for example use `crInstall()` that expands into `crInstallW()` if you use wide character set or into `crInstallA()` if you use multibyte character set.

== Why would I want to add a custom file to an error report? == 

Typically an application creates and maintains a log file where operations and errors are written. Such log file can be helpful for crash analysis and should be added to an error report. 

== Why would I want to generate error report without crash? ==

Sometimes it is required to remotely debug some application logics error. Such an error, for example, infinite loop, may not cause program crash. To collect the information about error that doesn't cause crash, a software developer might provide an ability to generate error report manually on user demand, for example on a key combination press. 

== What is the required way of CRT linkage for crashrpt to work properly? ==

It is important that you configure your project to use C runtime libraries (CRT) as Multi-threaded DLL (/MD) for Release configuration. This is the way recommended in MSDN. And current version of CrashRpt won't work properly if CRT is used in different way.

In the Solution Explorer window, right-click your project and open project Properties. Then choose Configuration Properties->C/C++->Code Generation. In the Runtime Library field, choose Multi-threaded DLL (/MD).

This should be done for all projects in your solution to share single CRT DLL.

== What do I do if modules of my application use different versions of CRT? ==

Ensure that all modules that exist in your application use the same version of CRT. If some dependent modules were compiled using an older version of CRT, you should recompile them to ensure the single version or CRT DLL is used.

For example, assume you use Visual Studio 2005 and CRT 8.0 linked as DLL, but some dependent module in your application was compiled in Visual Studio .NET 2003 and uses CRT 7.1 linked as DLL. In such situation a C++ exception in the dependent module won't be intercepted by CrashRpt, because CrashRpt will intercept exceptions in CRT 8.0 only.

== What do I do if my project uses CRT as a static library? ==

In such case you can't use current version of CrashRpt in your project, because it uses dynamically linked C runtime libraries (Multi-threaded DLL (/MD) compiler flag). For more information, see below.

Each module (EXE, DLL) in your project is linked to CRT (C runtime libraries). You may link CRT as multithreaded static library or as multithreaded dynamic link library. When you set CRT error handlers, such as pure call handler or invalid parameter handler, they will work for the CRT the caller module is linked to and won't intercept exceptions in different CRT modules (if exist).

Several project modules may share single CRT DLL. This reduces to minimum the overall size of linked CRT code. And all exceptions within that CRT DLL can be handled at once. That's why multithreaded CRT DLL is the recommended way of CRT linkage.

If your project uses CRT as a static link library (which is not recommended to do) and want to use some crash reporting functionality, you would have to compile the functionality as static a lib with /NODEFAULTLIB linker option. Then you would have to install CRT error handlers for EACH module that your program loads into its address space. CrashRpt doesn't support this currently. If you need such ability, please create an enhancement request in our issue tracker.

== Can I compile crashrpt as a static library? ==

No, currently you can't do this.

== Why should I enable Program Database (/Zi) compiler flag and Generate Debug Info (/DEBUG) linker flag? ==

To get the most out of the crash minidump, the debugger needs your application's debug symbols. By default Release builds don't generate debug symbols. The crash minidump is unusable without the debugging symbols database (program database, PDB). 

  # In the Solution Explorer window, right-click your project and open project Properties. Then choose Configuration Properties->C/C++->General. In the Debug Information Format field, choose Program Database (/Zi).
  # Choose Configuration Properties->Linker->Debugging. In the Generate Debug Info field, choose Yes (/DEBUG). In the Generate Program Database File field, enter the name for your PDB file, for example $(TargetDir)$(TargetName).pdb.
This should be done for all projects in your solution that support program database (EXE, DLL).

== Shoud I use rebase.exe to set preferred load address for modules of my application to be able read minidumps later? ==

This is not necessary, because a minidump file itself contains the list of loaded modules of your application and their actual load addresses. 

== Does crashrpt intercept _exactly_ all exceptions that may occur in my program? == 

CrashRpt intercepts all exceptions that are allowed to intercept by C runtime libraries.

Note that some exceptions related to security can't be intercepted. Since CRT 8.0 you can't intercept security errors in your code. When buffer overrun is detected, CRT invokes Watson directly instead of calling unhandled exception filter. This is done because of security reasons and Microsoft doesn't plan to change this behavior.

For more information, see the link https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=101337

== How do I test if crashrpt intercepts exceptions in my application? ==

When you install crash reporting support to your program, it is important to test if CrashRpt intercepts exceptions properly. Use `crEmulateCrash()` function to emulate an exceptional situation. Call this function in your `main` function and in the thread procedure of each of your working threads.

== What files do I save locally before my software is released? ==

When you are ready for a software release, the following steps must be performed to be able to properly read end user error reports later.

    * Create a directory, for example name it 'CrashRptSaved'.
    * In that directory create a subdirectory for your software release, for example 'MyApp v.1.3.5'.
    * Copy all binary files (.EXE, .DLL) from your project output.
    * Copy all program database files (.PDB) from your project output.

It is recommended to direct all project output to bin directory and then just copy entire bin directory. These steps should be performed for exactly the same software build that you plan to release. If you rebuild the project after files are copied, you must copy the files again.

It is good idea to automate these steps as a post-build event. That would guarantee you won't forget to copy the files.

When a crash report comes in, you use the release build and debug symbols you copied, along with the minidump included in the crash report, to debug the crash.

== What files should I never distribute with my software release package? ==

The files copied to CrashRptSaved directory should be stored locally during the software life time. The saved files should NOT be included in the software release package and should NOT be sent to end users. You should never ship debug builds or debug symbols (PDB files) as they will not only take up more space on your CD/download/client's machine, but they will also make reverse engineering your code a trivial exercise.

== What crashrpt files do I distribute with my software release package? == 

You must always distribute the following files with your software release.

    * `bin\CrashRpt.dll` 
    * `bin\CrashSender.exe` 
    * `dbghelp\bin\dbghelp.dll` 
    * `zlib\bin\zlib1.dll` (since v1.1.2 this file is not distributed)

It is recommended that you place these files to the directory where your application executable file is located.

The `CrashRpt.dll` and `CrashSender.exe` are core CrashRpt modules. `dbghelp.dll` (Microsoft Debug Help Library) and `zlib1.dll` (ZLib) are dependent modules. 

== I know that dbghelp.dll is shipped with Windows. Why should I distribute it? ==

It is recommended that you distribute dbghelp.dll with your software, because some end-user machines may not have dbghelp.dll installed or dbghelp.dll's version may be different on different user machines.

dbghelp.dll is shipped with Windows XP and later, so most user machines have this library installed. If your target OS is Windows XP and later, you may ignore distribution of dbghelp.dll at your own risk. 

== I do not like that I should distribute all these DLLs. Can I compile them all as static libs? ==

No, this is impossible.

Currently you can't compile CrashRpt as static lib. You may ignore distribution of dbghelp.dll, but a end user's operating system may not have dbghelp.dll installed. In addition, architecture of CrashRpt requires two modules: `CrashRpt.dll` and `CrashSender.exe`. So, you have to distribute all these binaries.

= Error Reports Creation and Delivery = 

== What is an error report? ==

An error report refers to a collection of files intended to help the developer diagnose the cause of a crash.

The error report contains crash minidump file (crashdump.dmp), which has operating system version, processor type, CPU registers state and local variables and stack trace for each execution thread. The minidump in most cases can be used on developer's side to determine the reason of the crash and try to fix the problem.

In addition, CrashRpt generates an XML crash descriptor file. The file contains various information that might be useful for crash analysis.

Custom files, for example, application log files, can be included into crash report via the crash callback. 

== How does crashrpt create an error report when crash occurs? ==

When crash occurs, CrashRpt builds and saves an error report and then runs another process named `CrashSender.exe`. The parent process is then terminated. If you generate error report manually, the parent process is not terminated.

CrashRpt saves an error report as a ZIP archive to `LOCAL_APP_DATA\CrashRpt\UnsentErrorReports\AppName_AppVersion` folder. 

In CrashRpt v1.1b, crash report files are not removed, even if they had been sent to the recipient successfuly.

Since CrashRpt v1.1.1, crash report files are removed after they had been sent to the recipient successfuly.

== What is the Privacy Policy? Where can I find a template for the Privacy Policy? ==

Since v.1.1.2 you can use a privacy policy which describes what user information your software collects on crash. You provide an URL of your privacy policy HTML document published on your web site or distributed with your software. 

If you need a template you may use this one: PrivacyPolicyTemplate.

== How does crashrpt deliver me error reports from end users? ==

CrashRpt sends error reports back to your software support team using any of the following ways:
  * via HTTP request to a server-side script
  * via connection to an SMTP server
  * via Simple MAPI programming interface (the user's default E-mail client application)

If one of these ways fails, CrashRpt tries others in turn. You can define the preferred order of ways used to send reports.

== Are there any crash report size limitations? ==

Yes, they are. A crash report should be as small as possible (~100 KB). This is because of limitations of size of email attachments and HTTP request size. If the error report is larger than the limit, it is possible that the error report won't be delivered to the software support team.

== How does crashrpt send me error reports using HTTP connection? ==

Many software products have web sites on the Internet. Such web servers typically have some scripting engine enabled, for example PHP, Perl and so on. CrashRpt can establish an HTTP connection to a server-side script and send an error report as a script parameter.

This way is not affected by firewalls, because most of firewalls have HTTP port 8080 open. However, this way requires a server with some script that you create and deploy yourself.

See CrashRpt project documentation for more information.

== How does crashrpt send me error reports using SMTP connection? ==

CrashRpt has a simple built-in SMPT client. It can try to send an error report to recipient using SMTP connection without any user interaction. The error report is sent as an E-mail multi-part message with attachments.

This way `CrashSender.exe` creates SMTP connection with a mail server (port 25) and sends crash reports without additional user interaction. There are two SMTP servers that can be used to relay email: sender's mailbox and recipient's mailbox. 

If user provides his/her email address, CrashRpt tries to use the address's MX domain record to determine local SMTP server name and relay the email message to that server.

If user doesn't provide his/her email address, CrashRpt tries to send the email directly to recipient using the MX record of recipent's domain. Many SMTP servers may block direct access to them to avoid spam (for example Google does so).

This way won't work when firewall is enabled and port 25 is closed for outbound traffic (SMTP client won't be able to even connect). Since many organizations and even home users have firewalls that silently block port 25, this way fails for many users. 

== How does crashrpt send me error reports using Simple MAPI programming interface? ==

CrashRpt can use the default E-mail client, for example, Mozilla Thunderbird, to send an error report as email. An error report is sent as an E-mail multi-part message with attachments. This requires some user interaction.

This way has the lowest priority by default. 

== What does crashrpt do when all attempts to send error report fail? == 

CrashRpt saves an error report as a ZIP archive to `LOCAL_APP_DATA\CrashRpt\UnsentErrorReports\AppName_AppVersion` folder. 

= Using Error Reports =

== What do I do when I start receiving error reports after software release? ==

When a software release is made and CrashRpt support is enabled in your software, sooner or later you start receiving crash reports.

Count of received crash reports may depend on robustness of your software to various exceptional situations and on how much your software popular. So it's nothing unusual if you receive hundreeds of error reports a day. If there are many incoming error reports, you can monitor and analyse them for the first few days after release, and prepare a hot fix release.

The purpose of an error report is to help you determine the reason of the problem and try to fix it. The keyword is 'try', because in most cases you can't fix crash reports as you usually do with normal bugs. You usually can't reproduce the error on your machine, so you can't guarantee it is fixed. So the only way to check is to make fixes in parts of code that could cause the crash most probably and to release a new version of software.

The normal scenario is that your software becomes more and more stable with each release and less and less error reports are received.

== How do I check integrity of a received error report?  ==

You may calculate MD5 hash for your error report and compare it with the MD5 hash that is attached to the error report. 

When you receive error reports using HTTP connection, the MD5 hash is passed to the server-side script through the 'md5' parameter. 

Since CrashRpt v1.1.1., when you receive error reports using email, the MD5 hash is attached to the email.

== How do I use an error report for debugging a crash? ==

A crash report is a small ZIP file (usually less than 100 KB in size) containing several files, such as
  * crash minidump (crashdump.dmp),
  * crash descriptor XML (crashrpt.xml),
  * and optionally application specific files, for example, application log files.

The crash descriptor is an XML file that contains the basic information about the crash,
for example exception type, operating system name, application name and version.
 
The crash dump file is a collection of memory ranges, CPU register states, the call stack and local variables for each excecution thread, the list of loaded and unloaded modules and system information. You can open the minidump in your Visual Studio or in WinDbg program and see the place of your code where exception had occurred. 

See the documentation contained in the CrashRpt release package for more information.

== How do I open a crash descriptor XML file? ==

You can use notepad or other text editor. Or you can use your web browser.

== What is crash GUID? ==

A crash descriptor XML contains `CrashGUID` tag. The crash GUID is an unique identifier that is assigned to an error report. GUIDs are generated using special algorithm that guarantees that there is very low probability of generating the same GUID twice on different user machines. The crash GUID can be used, for example, as a primary key if you plan to store crash reports in a database.

== How do I determine the name and version of the application that generated the error report?  ==

A crash descriptor XML contains `AppName` and `AppVersion` tags that you use to determine what application sent you the report. You are typically interested in analysing error reports from the latest version of your software and ignore reports from older versions.

== How do I determine the OS version for the error report? ==

A crash descriptor XML contains `OperatingSystem` tag that is the friendly name of end user's operating system, including name, build number and service pack. It is useful information because many errors are OS-specific.

== What is an `ExceptionType` tag in the crash descriptor XML? ==

The exception type shows what exception handler cathed the exception. For example, type 0 means that the structured win32 exception was intercepted by the unhandled exception filter set with `SetUnhandledExceptionFilter()` function. The exception type can be used to divide exceptions in some categories. 

== How do I open a crash minidump file (.DMP)? ==

To open crash minidump, copy it to the directory where the binaries (EXE, DLLs) and program database files (PDB) are locally stored. You copy the minidump to that folder to ensure the debugger find the program database files and binaries. Then double-click on the minidump file name. This should open it using an associated program (for example, Visual Studio). When minidump file is loaded in Visual Studio, press F5 to run it. If debug symbols are loaded successfuly, you are now able to see the place in your source code where exception had occurred.

Alternatively, you can open the minidump file using WinDbg program from Microsoft Debugging Tools that is freely distributed.

== I open minidump, but symbols are not loaded. What do I do? ==

Sometimes you can't determine the location of the crash and the error message is displayed 'No symbols loaded for any stack frame'. This may be because of the following reasons.

  * Debugger may not locate the correct PDB and binary files. Try to open Tools->Options->Debugging->Symbols and enter the path to the directory where your PDB files are located. Then reopen the minidump.

  * You have wrong or missing PDB files. Open the Modules window and check the symbol status for modules of your program. If the status is 'Not loaded' than you have missing PDB. Or maybe correct PDB files weren't saved locally before software release. In such case you won't be able to properly read any of received crash reports.

  * If symbols for some modules of your program are loaded, and you have the error, than there were no debugging symbols generated for the module where crash had occured. Check that you set Program Database (/Zi) compiler flag for all modules of your application.