#summary Frequently Asked Questions
#labels Featured,Phase-Deploy

<wiki:toc max_depth="2" />

= General Questions =

== What is crashrpt? ==

CrashRpt library is a light-weight error handling framework. The library will intercept a Win32 structured exception and a C++ exception generated by a user-mode application. CrashRpt DLL works like Dr. Watson utility that ships with Windows XP, or like Windows Error Reporting in Windows Vista. CrashRpt intercepts an unhandled exception, creates a minidump, builds a crash descriptor in XML format, presents an interface to allow user to review the crash report, and finally it compresses and sends the crash report to the software support team.

== What is an exception? ==

An exception or a critical error typically means that a program stops working normally and needs to stop its execution.

For example, an exception may occur because of the following:

  * program accesses an invalid memory address (such as NULL pointer)
  * stack is overflown due to infinite recursion
  * large block of data is written to a small buffer
  * a pure virtual method of a C++ class is called
  * memory buffer can't be allocated (out of memory)
  * invalid parameter is passed to a C++ system function
  * C++ run time libraries detect an error and request program termination

== Why should I use crashrpt in my Visual C++ project? ==

CrashRpt provides functionality to properly handle structured Win32 exceptions, C++ runtime libraries (CRT) errors and C++ interruption signals. It would take a lot of efforts from you to implement this yourself. CrashRpt collects all information you need to debug the problem. CrashRpt can deliver error reports using HTTP request, SMTP connection and through Simple MAPI. In addition, CrashRpt is well documented, so its easy to start using it in your project.

== What is current crashrpt project status? ==

The latest version of CrashRpt is v1.1 beta. We are currently preparing for the v1.1 final release. 

The previous version, CrashRpt v1.0 is declared deprecated and not recommended for download.

== Are there  any analogous software for crash reporting? ==

Yes, they are listed in the table below:

|| *Name* || *Description* || *Link* ||
|| google-breakpad || An open-source multi-platform crash reporting system || http://code.google.com/p/google-breakpad/ ||
|| Mozilla Firefox Crash Reporting System || Used in Mozilla Firefox browser || https://developer.mozilla.org/en/Crash_reporting ||
|| Windows Error Reporting || Embed into Windows Vista and later || http://msdn.microsoft.com/en-us/isv/bb190483.aspx ||

= Using crashrpt =

== What Visual C++ versions I can use crashrpt in? ==

Since v1.1 of CrashRpt you can use CrashRpt in Visual C++ .NET 2003, Visual C++ 2005 and Visual C++ 2008. Visual C++ 6.0 is not supported anymore.

== Where do I look for crashrpt documentation? ==

In the newest version of CrashRpt, the documentation is included into the CrashRpt release package. To open the documentation, click the `index.html` in the top level directory of the CrashRpt package.

In an older version of CrashRpt v1.0, the documentation can be found in [CrashRpt_v1_0_Documentation] wiki page and also in [http://www.codeproject.com/KB/debug/crash_report.aspx http://www.codeproject.com/KB/debug/crash_report.aspx] article.

== How do I properly install crashrpt? ==

Download the latest stable version of CrashRpt from the [http://code.google.com/p/crashrpt/downloads/list Downloads] page. Unzip the archive to any folder, then go to the top level directory and click the index.html file to open project documentation. Then follow the directions in Installation page of the documentation.

== How do I use crashrpt in my Visual C++ project? ==

Go to the top level directory of CrashRpt package and click the index.html file to open project documentation. Then follow the directions in Using CrashRpt in Your Visual C++ Project page of the documentation.

== What is an error report? ==

An error report refers to a collection of files intended to help the developer diagnose the cause of a crash.

The error report contains crash minidump file (crashdump.dmp), which has operating system version, processor type, CPU registers state and local variables and stack trace for each execution thread. The minidump in most cases can be used on developer's side to determine the reason of the crash and try to fix the problem.

In addition, CrashRpt generates an XML crash descriptor file. The file contains various information that might be useful for crash analysis.

Custom files, for example, application log files, can be included into crash report via the crash callback. 

== How crashrpt delivers me error reports from end users? ==

CrashRpt sends error reports back to your software support team using any of the following ways:
  * via HTTP request to a server-side script
  * via connection to an SMTP server
  * via Simple MAPI programming interface (the user's default E-mail client application)

== What do I do when I start receiving error reports after software release? ==

When a software release is made and CrashRpt support is enabled in your software, sooner or later you start receiving crash reports.

Count of received crash reports may depend on robustness of your software to various exceptional situations and on how much your software popular. So it's nothing unusual if you receive hundreeds of error reports a day. If there are many incoming error reports, you can monitor and analyse them for the first few days after release, and prepare a hot fix release.

The purpose of an error report is to help you determine the reason of the problem and try to fix it. The keyword is 'try', because in most cases you can't fix crash reports as you usually do with normal bugs. You usually can't reproduce the error on your machine, so you can't guarantee it is fixed. So the only way to check is to make fixes in parts of code that could cause the crash most probably and to release a new version of software.

The normal scenario is that your software becomes more and more stable with each release and less and less error reports are received.

== How do I use an error report for debugging a crash? ==

A crash report is a small ZIP file (usually less than 100 KB in size) containing several files, such as
  * crash minidump (crashdump.dmp),
  * crash descriptor XML (crashrpt.xml),
  * and optionally application specific files, for example, application log files.

The crash descriptor is an XML file that contains the basic information about the crash,
for example exception type, operating system name, application name and version.
 
The crash dump file is a collection of memory ranges, CPU register states, the call stack and local variables for each excecution thread, the list of loaded and unloaded modules and system information. You can open the minidump in your Visual Studion or in WinDbg program and see the place of your code where exception had occurred. 

See the documentation contained in the CrashRpt release package for more information.

== How do I open a crash minidump file (.DMP) ==

To open crash minidump, copy it to the directory where the binaries (EXE, DLLs) and program database files (PDB) are locally stored. You copy the minidump to that folder to ensure the debugger find the program database files and binaries. Then double-click on the minidump file name. This should open it using an associated program (for example, Visual Studio). When minidump file is loaded in Visual Studio, press F5 to run it. If debug symbols are loaded successfuly, you are now able to see the place in your source code where exception had occurred.

== I open minidump, but symbols are not loaded. What do I do? ==

Sometimes you can't determine the location of the crash and the error message is displayed 'No symbols loaded for any stack frame'. This may be because of the following reasons.

  * Debugger may not locate the correct PDB and binary files. Try to open Tools->Options->Debugging->Symbols and enter the path to the directory where your PDB files are located. Then reopen the minidump.

  * You have wrong or missing PDB files. Open the Modules window and check the symbol status for modules of your program. If the status is 'Module not loaded' than you have missing PDB. Or maybe correct PDB files weren't saved locally before software release. In such case you won't be able to properly read any of received crash reports.

  * If symbols for some modules of your program are loaded, and you have the error, than there were no debugging symbols generated for the module where crash had occured. Check that you set Program Database (/Zi) compiler flag for all modules of your application.

== What is the required way of CRT linkage for crashrpt to work properly? ==

It is important that you configure your project to use C++ runtime libraries (CRT) as Multi-threaded DLL (/MD) for Release configuration. This is the way recommended in MSDN. And CrashRpt won't work properly if CRT is used in different way.

In the Solution Explorer window, right-click your project and open project Properties. Then choose Configuration Properties->C/C++->Code Generation. In the Runtime Library field, choose Multi-threaded DLL (/MD).

This should be done for all projects in your solution to share single CRT DLL.

== What do I do if modules of my application use different versions of CRT? ==

Ensure that all modules that exist in your application use the same version of CRT. If some dependent modules were compiled using an older version of CRT, you should recompile them to ensure the single version or CRT DLL is used.

For example, assume you use Visual Studio 2005 and CRT 8.0 linked as DLL, but some dependent module in your application was compiled in Visual Studio .NET 2003 and uses CRT 7.1 linked as DLL. In such situation a C++ exception in the dependent module won't be intercepted by CrashRpt, because CrashRpt will intercept exceptions in CRT 8.0 only.

== What do I do if my project uses CRT as a static library? ==

In such case you can't use CrashRpt in your project, even if you compile it as a static library.

Each module (EXE, DLL) in your project is linked to CRT (C++ runtime libraries). You may link CRT as multithreaded static library or as multithreaded dynamic link library. When you set CRT error handlers, such as pure call handler or invalid parameter handler, they will work for the CRT the caller module is linked to and won't intercept exceptions in different CRT modules (if exist).

Several project modules may share single CRT DLL. This reduces to minimum the overall size of linked CRT code. And all exceptions within that CRT DLL can be handled at once. That's why multithreaded CRT DLL is the recommended way of CRT linkage.

If you plan to use CRT as a static link library (which is not recommended to do), you have to add exception handling functionality in EACH project module in your solution in form of .cpp files. This makes impossible the way when you implement exception handling code inside of a dynamic link library (such way CrashRpt is implemented).

== Does crashrpt intercepts _exactly_ all exceptions that may occur in my program? == 

CrashRpt intercepts all exceptions that are allowed to intercept by C++ runtime libraries.

Note that some exceptions related to security can't be intercepted. Since CRT 8.0 you can't intercept security errors in your code. When buffer overrun is detected, CRT invokes Watson directly instead of calling unhandled exception filter. This is done because of security reasons and Microsoft doesn't plan to change this behavior.

For more information, see the link https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=101337
